# 객체과 관계형 데이터베이스의 차이

1. 상속
2. 연관관계
3. 데이터 타입
4. 데이터 식별 방법

객체는 '참조'를 사용
테이블은 '외래 키'를 사용

엔티티 신뢰 문제?

객체를 자바 컬렉션에 저장 하듯이 db에 저장할 수 없을까? -> jpa

JPA는 자바 표준 ORM이라고 할 수 있다.
ORM(Object relational mapping) 객체 관계 매핑이다.
객체는 객체대로 설계, 관계형 데이터베이스는 관계형 데이터베이스대로 설계
ORM 프레임워크가 중간에서 매핑, 대중적인 언어에는 대부분 ORM 기술이 존재

JPA는 표준 명세(인터페이스의 모음)

지연로딩과 즉시로딩
-> 지연로딩 : 객체가 실제 사용될 때 로딩
-> 즉시로딩 : JOIN SQL로 한 번에 연관된 객체까지 미리 조회

JPA 설정한다?
persistence.xml 파일을 만들어서 프로젝트에 넣어야 한다.
표준 위치가 정해져 있는데,
/META-INF/persistence.xml에 위치해야한다.
main에 resources 폴더에 META-INF 디렉토리를 만들고 persistence.xml을 만들어서
코드 복붙한다.
-> 그러면 인텔리제이가 알아서 개발자가 JPA 쓰는 줄 알고 인식해줌

데이터베이스 방언(SQL 표준을 지키지 않는 특정 데이터베이스만의 고유한 기능)
-> JPA는 특정 데이터베이스에 종속 X
-> 각각의 데이터베이스가 제공하는 SQL 문법과 함수는 조금씩 다름

###JPQL###
JPA를 사용하면 엔티티 객체를 중심으로 개발
-> 기존의 테이블 중심의 SQL과 다름
문제는 검색 쿼리
검색을 할 때도 테이블이 아닌 엔티티 객체를 대상으로 검색
모든 DB 데이터를 객체로 변환해서 검색하는 것은 불가능
애플리케이션이 필요한 데이터만 DB에서 불러오려면 결국 검색 조건이 포함된 SQL이 필요

JPA는 SQL을 추상화한 JPQL이라는 객체 지향 쿼리 언어 제공
SQL과 문법 유사, SELECT, FROM, WHERE, GROUO BY, HAVING, JOIN 지원
JPQL은 엔티티 객체를 대상으로 쿼리
SQL은 데이터베이스 테이블을 대상으로 쿼리
테이블이 아닌 객체를 대상으로 검색하는 객체 지향 쿼리
SQL을 추상화해서 특정 데이터베이스 SQL에 의존하지 않음
JPQL을 한마디로 정의하면 객체 지향 SQL

####### JPA에서 가장 중요한 2가지 ########

- 객체와 관계형 데이터베이스 매핑하기
- 영속성 컨텍스트

엔티티 매니저 팩토리와 엔티티 매니저

- 고객의 요청이 올 때마다 엔티티 매니저 팩토리에서 엔티티 매니저를 각각의 요청마다 생성해줌
- 엔티티 매니저는 내부적으로 데이터베이스 커넥션을 사용해서 DB를 사용한다.

영속성 컨텍스트란?

- 엔티티를 영구 저장하는 환경
- EntityManager.persist(entity);
- 영속성 컨텍스트는 논리적인 개념
- 눈에 보이지 않는다
- 엔티티 매니저를 통해서 영속성 컨텍스트에 접근한다
- 엔티티 매니저가 생성되면 영속성 컨텍스트를 1:1로 생성

#######엔티티의 생명주기########

- 비영속 : 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태
- 영속(managed) : 영속성 컨텍스트에 관리되는 상태
- 준영속(detached) : 영속성 컨텍스트에 저장되었다가 분리된 상태
- 삭제(removed) : 삭제된 상태

// 비영속
Member member = new Member();
member.setId(100L);
member.setName("HelloJPA");

// 영속
em.persist(member);

-> 영속상태가 된다고해서 DB에 쿼리가 바로 날아가는게 아니다!!!
-> 트랜잭션에 커밋하는 시점에 날아간다

// 준영속, 삭제
// 회원 엔티티를 영속성 컨텍스트에서 분리, 준영속 상태
em.detach(member);
// 객체를 삭제한 상태(삭제)
em.remove(member);

############ 영속성 컨텍스트의 이점 #############

- 1차 캐시
- 동일성(identity) 보장
- 트랜잭션을 지원하는 쓰기 지연 (transactional write-behind)
- 변경 감지 (dirty checking)
- 지연 로딩 (lazy loading)

엔티티 조회, 1차 캐시
// 엔티티를 생성한 상태(비영속)
Member member = new Member();
member.setId("member1");
member.setUsername("회원1");

// 1차 캐시에 저장됨
em.persist(member);

// 1차 캐시에서 조회
Member findMember = em.find(Member.class, "member1");

영속 엔티티의 동일성 보장
Member a = em.find(Member.class, "member1");
Member b = em.find(Member.class, "member1");

System.out.println(a==b); // 동일성 비교 true

1차 캐시로 반복 가능한 읽기(REPEATABLE READ) 등급의 트랜잭션 격리 수준을
데이터베이스가 아닌 애플리케이션 차원에서 제공

트랜잭션을 지원하는 쓰기 지연
트랜잭션을 실행하면, persist(memberA), persist(memberB)를 1차 캐시에 저장하고
INSERT SQL 생성해서 '쓰기 지연 SQL 저장소'에 차곡차곡 쌓아 놓는다.

DB에 저장하는 시점은?
-> transaction.commit();
을 하면 flush가 되면서 '쓰기 지연 SQL 저장소'에 있던 데이터가 날아간다.

엔티티 삭제
// 삭제 대상 엔티티 조회
Member memverA = em.find(Member.class, "memberA");
em.remove(memberA);   // 엔티티 삭제

#############################################

플러시란?
영속성 컨텍스트의 변경내용을 데이터베이스에 적용

플러시 발생

- 변경 감지
- 수정된 엔티티 쓰기 지연 SQL 저장소에 등록
- 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송
  (등록, 수정, 삭제 쿼리)

영속성 컨텍스트를 플러시하는 방법

- em.flush() : 직접 호출
- 트랜잭션 커밋 : 플러시 자동 호출
- JPQL 쿼리 실행 : 플러시 자동 호출

플러시는!

- 영속성 컨텍스트를 비우지 않음
- 영속성 컨텍스트의 변경내용을 데이터베이스에 동기화
- 트랜잭션이라는 작업 단위가 중요! (트랜잭션 커밋 직전에만 동기화하면 된다)

######### 준영속 ################
em.detach(entity)
-> 특정 엔티티만 준영속 상태로 전환
em.clear()
-> 영속성 컨텍스트를 완전히 초기화
em.close()
-> 영속성 컨텍스트를 종료



------------------------------------------------------------------------------------------------------------------------------

4 / 25



 자바 - 엔티티 매핑

1. 객체와 테이블 매핑
2. 데이터베이스 스키마 자동 생성
3. 필드와 컬럼 매핑
4. 기본 키 매핑
5. 실전 예제 
   (1) 요구사항 분석과 기본 매핑

엔티티 매핑 소개

- 객체와 테이블 매핑: @Entity, @Table
- 필드와 컬럼 매핑 : @Column
- 기본 키 매핑 : @Id
- 연관관계 매핑 : @ManyToOne, @JoinColumn

###### 객체와 테이블 매핑

@Entity

- @Entity가 붙은 클래스는 JPA가 관리, 엔티티라 한다.
- JPA를 사용해서 테이블과 매핑할 클래스는 @Entity 필수
  주의
- 기본 생성자 필수(파라미터가 없는 public 또는 protected 생성자)
- final 클래스, enum, interface, inner 클래스 사용X
- 저장할 필드에 final 사용X

############## 데이터베이스 스키마 자동 생성################

- DDL을 애플리케이션 실행 시점에 자동 생성
- 테이블 중심 -> 객체 중심
- 데이터베이스 방언을 활용해서 데이터베이스에 맞는 적절한 DDL 생성
- 이렇게 생성된 DDL은 개발 장비에서만 사용
- 생성된 DDL은 운영서버에서는 사용하지 않거나, 적절히 다듬은 후 사용

데이터베이스 스키마 자동생성 - 속성
create : 기존테이블 삭제 후 다시 생성(DROP + CREATE)
create-drop : create와 같으나 종료시점에 테이블 DROP
update : 변경분만 반영(운영 DB에는 사용하면 안됨)
validate : 엔티티와 테이블이 정상 매핑되었는지만 확인
none : 사용하지 않음

데이터베이스 스키마 자동 생성 (주의)
-> 운영 장비에는 절대 create, create-drop, update 사용하면 안 된다.
-> 개발 초기 단계는 create 또는 update
-> 테스트 서버는 update 또는 validate
-> 스테이징과 운영 서버는 validate 또는 none

매핑 어노테이션 정리
@Column    ->   컬럼 매핑
@Temporal  ->   날짜 타입 매핑
@Enumerated  ->  enum 타입 매핑
@Lob    -> BLOB, CLOB 매핑
@Transient   -> 특정 필드를 컬럼에 매핑

기본 키 매핑 어노테이션
@Id
@GeneratedValue

@Id @GeneratedValue(strategy = GenerationType.AUTO)
private Long id;

기본 키 매핑 방법

- 직접 할당 : @Id만 사용
- 자동 생성(@GeneratedValue)
  - IDENTITY : 데이터베이스에 위임, MYSQL
  - SEQUENCE : 데이터베이스 시쿼스 오브젝트 사용, ORACLE
      @SequenceGenerator 필요
  - TABLE : 키 생성용 테이블 사용, 모든 DB에서 사용
      @TableGenerator 필요
  - AUTO : 방언에 따라 자동 지정, 기본값

권장하는 식별자 전략

- 기본 키 제약 조건 : null 아님, 유일, 변하면 안 된다.
- 미래까지 이 조건을 만족하는 자연키는 찾기 어렵다. 대리키(대체키)를 사용하자.
- 예를 들어 주민등록번호도 기본 키로 적절하지 않다.
  (국가에서 주민등록번호를 저장하지 말라고 권고함, 기본키는 외래키로 다 들고 있으니까
  바꿔야 하는 경우 전체 테이블을 다 까서 바꿔야함.)
- 권장 : Long형 + 대체키 + 키 생성전략 사용

########### IDENTITY 전략 ###########

- 기본 키 생성을 데이터베이스에 위임
- 주로 MYSQL, PostgreSQL, SQL Server, DB2에서 사용
  (예 : MYSQL의 AUTO_INCREMENT)
- JPA는 보통 트랜잭션 커밋 시점에서 INSERT SQL 실행
- AUTO_INCREMENT는 데이터베이스에 INSERT SQL을 실행한 이후에
  ID값을 알 수 있음
- IDENTITY 전략은 em.persist() 시점에 즉시 INSERT SQL 실행하고
  DB에서 식별자를 조회

@SequenceGenerator는 시퀀스 생성기를 설정하는 어노테이션이다
DB에서 생성한 시퀀스를 맵핑하고 맵핑된 시퀀스를 통해 시퀀스를 생성하는
역할을 한다. 

########### @SequenceGenerator 애노테이션 ############
DB에 생성한 시퀀스를 바탕으로 식별자를 생성하는 시퀀스 생성기를 설정하는 애노테이션이다. 
클래스 단위 또는 식별자 필드에서 @GeneratedValue 애노테이션 설정과 함께 사용 가능하다.

name
-> @GeneratedValue에서 지정할 수 있는 시퀀스 생성기 이름을 등록
-> 필수값

sequenceName
-> 데이터베이스에 생성해둔 시퀀스 이름
-> hibernate_sequence

initialValue
-> DDL 생성 하는경우 사용하며, 
-> 시퀀스를 생성할 DDL에서 처음 시작하는 값을 지정.
-> 1

allocationSize
-> JPA에서 가상으로 관리할 시퀀스 할당 범위로 성능 최적화를 위해 값을 수정할 수 있다
-> 기본값은 50이며, 1로 설정하는 경우 매번 insert시마다 DB의 시퀀스를 호출한다.
-> 50

catalog, schema
-> DB의 카타로그와 스키마 이름

########### 데이터 중심 설계의 문제점 ###########

- 현재 방식은 객체 설계를 테이블 설계에 맞춘 방식
- 테이블의 외래키를 객체에 그대로 가져옴
- 객체 그래프 탐색이 불가능
- 참조가 없으므로 UML도 잘못됨



---

4/25



연관관계 매핑 기초
목표

- 객체와 테이블 연관관계의 차이를 이해
- 객체의 참조와 테이블의 외래키를 매핑
  용어 이해
- 방향 : 단방향, 양방향
- 다중 : 다대일(N:1), 일대다(1:N), 일대일(1:1), 다대다(N:M) 이해
- 연관관계의 주인 : 객체 양방향 연관관계는 관리 주인이 필요

목차

- 연관관계가 필요한 이유
- 단방향 연관관계
- 양방향 연관관계와 연관관계의 주인
- 실전 예제 2. 연관관계 매핑 시작

객체를 테이블에 맞추어 데이터 중심으로 모델링하면, 협력 관계를 만들 수 없다.

- 테이블은 외래 키로 조인을 사용해서 연관된 테이블을 찾는다
- 객체는 참조를 사용해서 연관된 객체를 찾는다
- 테이블과 객체 사이에는 이런 큰 간격이 있다

// 팀 저장
Team team = new Team();
team.setName("TeamA");
em.persist(team);

// 회원 저장
Member member = new Member();
member.setName("member1");
member.setTeam(team);    // 단방향 연관관계 설정, 참조 저장
em.persist(member);

// 새로운 팀B
Team teamB = new Team();
teamB.setName("TeamB");
em.persist(teamB);
// 회원1에 새로운 팀B 설정
member.setTeam(teamB);

###############  양방향 연관관계와 연관관계의 주인 ##############
@ManyToOne  다대일
@OneToMany  일대다

양방향 매핑
@Entity
public class Team {
    @Id @GeneratedValue
    private Long id;
    private String name;

    @OneToMany(mappedBy = "team")
    List<Member> members = new ArrayList<Member>();

}

양방향 매핑(반대 방향으로 객체 그래프 탐색)
// 조회
Team findTeam = em.find(Team.class, team.getId());
// 역방향 조회
int memberSize = findTeam.getMembers().size(); 

연관관계의 주인과 mappedBy

- mappedBy = JPA의 멘탈붕괴 난이도
- mappedBy는 처음에 이해하기 어렵다.
- 객체와 테이블간에 연관관계를 맺는 차이를 이해해야 한다.

객체와 테이블이 관계를 맺는 차이

- 객체 연관관계 = 2개
  회원 -> 팀 연관관계 1개(단방향)
  팀    -> 회원 연관관계 1개(단방향)

- 테이블 연관관계 = 1개
  회원 <-> 팀의 연관관계 1개(양방향)

객체의 양방향 관계는 사실 양방향 관계가 아니라 서로 다른 단방향 관계 2개다
객체를 양방향으로 참조하려면 단방향 연관관계를 2개 만들어야 한다.

class A {
    B b ;
}

class B {
    A a ;
}

A -> B(a.getB())
B -> A(b.getA())

테이블의 양방향 연관관계

- 테이블은 '외래 키' 하나로 두 테이블의 연관관계를 관리
- MEMBER.TEAM_ID '외래 키' 하나로 양방향 연관관계 가짐
  (양쪽으로 조인할 수 있다)

SELECT *
FROM MEMBER M
JOIN TEAM T ON M.TEAM_ID = T.TEAM_ID

SELECT *
FROM TEAM T
JOIN MEMBER M ON T.TEAM_ID = M.TEAM_ID

연관관계의 주인(Owner)
양방향 매핑 규칙

- 객체의 두 관계 중 하나를 연관관계의 주인으로 지정
- **연관관계의 주인만이 외래 키를 관리(등록, 수정)
- **주인이 아닌쪽은 읽기만 가능
- 주인은 mappedBy 속성 사용X
- 주인이 아니면 mappedBy 속성으로 주인 지정
  (어떤 객체에 의해 매핑되었다 == 어떤 객체를 주인으로 모심)

#### 누구를 주인으로?

- 외래 키가 있는 곳을 주인으로 정해라

############# 양방향 매핑시 가장 많이 하는 실수 #############
(연관관계의 주인에 값을 입력하지 않음)

Team team = new Team();
team.setName("TeamA");
em.persist(team);

Member member = new Member();
member.setName("member1");

// 역방향(주인이 아닌 방향)만 연관관계 설정
team.getMembers().add(member);
em.persist(member);

############ 양방향 매핑시 연관관계의 주인에 값을 입력해야 한다 #############
(순수한 객체 관계를 고려하려면 항상 양쪽다 값을 입력해야 한다.)
Team team = new Team();
team.setName("TeamA");
em.persist(team);

Member member = new Member();
member.setName("member1");

team.getMembers().add(member);
// 연관관계의 주인에 값 설정
member.setTeam(team);   // **

em.persist(member);

양방향 연관관계 주의 - 실습

- 순수 객체 상태를 고려해서 항상 양쪽에 값을 설정하자
- 연관관계 편의 메소드를 생성하자
- 양방향 매핑시에 무한 루프를 조심하자
  ex) toString(), lombok, JSON 생성 라이브러리

연관관계의 주인을 정하는 기준

- 비지니스 로직을 기준으로 연관관계의 주인을 선택하면 안됨
- 연관관계 주인은 외래 키의 위치를 기준으로 정해야함 



-------------------------------------------------------------------------------------------------------------



4/26



목차
연관관계 매핑시 고려사항 3가지

- 다대일 [N:1]
- 일대다[1:N]
- 일대일[1:1]
- 다대다[N:M]
- 실전 예제 3. 다양한 연관관계 매핑

연관관계 매핑시 고려사항 3가지

- 다중성
  다대일 : @ManyToOne
  일대다 : @OneToMany
  일대일 : @OneToOne
  다대다 : @ManyToMany

- 단방향, 양방향
  테이블
  
  - 외래 키 하나로 양쪽 조인 가능
  - 사실 방향이라는 개념이 없음
    객체
  - 참조용 필드가 있는 쪽으로만 참조 가능
  - 한쪽만 참조하면 단방향
  - 양쪽이 서로 참조하면 양방향

- 연관관계의 주인
  테이블은 외래 키 하나로 두 테이블이 연관관계를 맺음
  객체 양방향 관계는 A->B, B->A 처럼 참조가 2군데
  객체 양방향 관계는 참조가 2군데 있음. 둘중 테이블의 외래 키를 관리할 곳을 지정해야함.
  연관관계의 주인 : 외래 키를 관리하는 참조
  주인의 반대편 : 외래 키에 영향을 주지 않음, 단순 조회만

다대일 양방향 정리

- 외래 키가 있는 쪽이 연관관계의 주인
- 양쪽을 서로 참조하도록 개발

일대다 단방향 정리

- 일대다 단방향은 일대다(1:N)에서 일(1)이 연관관계의 주인

- 테이블 일대다 관계는 항상 다(N) 쪽에 외래 키가 있음

- 객체와 테이블의 차이 때문에 반대편 테이블의 외래 키를 관리하는 특이한 구조

- @JoinColumn을 꼭 사용해야 함. 그렇지 않으면 조인 테이블 방식을 사용함
  (중간에 테이블을 하나 추가함)

- 일대다 단방향 매핑의 단점
  
  - 엔티티가 관리하는 외래 키가 다른 테이블에 있음
  - 연관관계 관리를 위해 추가로 UPDATE SQL 실행

- 일대다 단방향 매핑보다는 '다대일 양방향 매핑을 사용'하자

일대다 양방향 정리

- 이런 매핑은 공식적으로 존재X
- @JoinColumn(insertable=false, updatable=false)
- 읽기 전용 필드를 사용해서 양방향 처럼 사용하는 방법
- 다대일 양방향을 사용하자

일대일 관계

- 일대일 관계는 그 반대도 일대일
- 주 테이블이나 대상 테이블 중에 외래 키 선택 가능
  - 주 테이블에 외래 키
  - 대상 테이블에 외래 키
- 외래 키에 데이터베이스 유니크(UNI) 제약조건 추가

일대일 : 대상 테이블에 외래 키 단방향 정리

- 단방향 관계는 JPA 지원X
- 양방향 관계는 지원

일대일 정리

- 주 테이블에 외래 키
  - 주 객체가 대상 객체의 참조를 가지는 것처럼
    주 테이블에 외래 키를 두고 대상 테이블을 찾음
  - 객체지향 개발자 선호
  - JPA 매핑 편리
  - 장점 : 주 테이블만 조회해도 대상 테이블에 데이터가 있는지 확인 가능
  - 단점 : 값이 없으면 외래 키에 null 허용
- 대상 테이블에 외래 키
  - 대상 테이블에 외래 키가 존재
  - 전통적인 데이터베이스 개발자 선호
  - 장점 : 주 테이블과 대상 테이블을 일대일에서 일대다 관계로 변경할 때 테이블 구조 유지
  - 단점 : 프록시 기능의 한계로 '지연 로딩으로 설정해도 항상 즉시 로딩'됨

다대다

- 관계형 데이터베이스는 정규화된 테이블 2개로 다대다 관계를 표현할 수 없음

- 연결 테이블을 추가해서 일대다, 다대일 관계로 풀어내야함

- 객체는 컬렉션을 사용해서 객체 2개로 다대다 관계 가능

- @ManyToMany 사용

- @JoinTable로 연결 테이블 지정

- 다대다 매핑 : 단방향, 양방향 가능

- 편리해 보이지만 실무에서 사용X

- 연결 테이블이 단순히 연결만 하고 끝나지 않음

- 주문시간, 수량 같은 데이터가 들어올 수 있음

다대다 한계 극복

- 연결 테이블용 엔티티 추가(연결 테이블을 엔티티로 승격)
- @ManyToMany -> @OneToMany, @ManyToOne

######## @JoinColumn ########
외래 키를 매핑할 때 사용

name(매핑할 외래 키 이름)
-> 필드명 + _ + 참조하는 테이블의 기본 키 컬럼명

referencedColumnName(외래 키가 참조하는 대상 테이블의 컬럼명)
-> 참조하는 테이블의 기본 키 컬럼명

foreignKey(DDL)
-> 외래 키 제약조건을 직접 지정할 수 있다.
    이 속성은 테이블을 생성할 때만 사용한다.
